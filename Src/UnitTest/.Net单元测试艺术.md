# .Net单元测试艺术    
## VS Code 进行C#单元测试           
* 创建解决方案：dotnet new sln   
* 创建项目：dotnet new console/classlib/mstest/xunit -o projectName                 
* 添加项目到解决方案：dotnet sln add *.csproj ...      
* 添加项目之间引用：dotnet add A.csproj reference B.csproj   
* 添加外部引用：dotnet add package Newtonsoft.Json --version 11.0.1      
* 构建解决方案：dotnet build       
* 运行解决方案：doenet run -p projectName                                  
* 运行测试：dotnet test                           
* 发布项目：dotnet public -o path            
* 发布指定平台项目：dotnet publish -c Release -r win10-x64 [参考](https://stackoverflow.com/questions/44074121/build-net-core-console-application-to-output-an-exe)                                      

## 单元测试的基本知识     
* 单元测试 是一段自动化的代码，用来调用被测试的方法或类，而后验证基于该方法或类的逻辑行为的一些假设。单元测试几乎总是用单元测试框架来写的。它写起来很顺手，运行起来不费时，姿势全自动的，可信赖的，可读性强的，可维护的。                                                 
* SUT System Under Test 被测系统      
* 单元测试应具有的特性：1.自动的、可重复的；2.容易实现；3.一旦写好，将来都可使用；4.任何人都可运行；5.单击一个按钮就可运行；6.可以快速地运行。
* 集成测试 意味着把两个或多个相依赖的软件模块作为一组进行测试。集成测试运行多个集成到一起的代码单元，用来确认软件中应该出现的一个或多个预期结果。而单元测试通常只孤立地运行和测试某一个单元。            
* TDD 测试驱动开发：写测试，写代码，重构，写下一个测试        
* 优秀单元测试特性：1.一段自动化代码，它调用一个方法，然后检查基于该方法或类逻辑行为的一些假设；2.使用单元测试框架；3.写起来很容易；4.运行起来很快；5.开发团队中任何人都能重复运行      

## 第一个单元测试                    
* .net core 同时支持mstest和xunit.net                
* 一个单元测试通常包括以下三个主要部分：1.配置对象，根据需要新建和设置它们；2.操控对象；3.通过断言Assert判断结果是否符合预期。               
* 所有测试之间应该没有任何依赖关系，有两个方法用于在测试前设置状态和在测试后清理状态:mstest([TestInitialize],[TestInitialize])和xunit.net(Constructor,Dispose)，同时，还有相应的类初始化/清理和程序集初始化/清理，使用时机各不相同。                  
* 测试命名：项目名：[被测项目].Tests；类名：[被测类]Tests；方法名：方法名_测试场景或条件_预期结果。                        
* 验证预期的异常 被测试方法应该抛出异常时，应确保这个异常能够被正确抛出。相关特性举例：[ExpectedException(typeof(ArgumentException))]                      
* 单元测试也可以被忽略，对于特性[Ignore]。                                
* 基于状态的测试，也称状态验证，是指在方法执行之后，通过检查被测系统及其协作组（依赖项）的状态来验证改方法是否正确工作。                           

## 使用桩对象解除依赖                            
* 外部依赖  是指在系统中代码与其交互的对象，而且无法对其做人为控制。（常见的例子是文件系统、线程、内存和时间等）。                      
* 代码伪造模式 有多种，比较常用的有：伪对象（fake）、桩对象（stub）和模拟对象（mock）。                             
* 桩对象（Stub） 是对系统中现有依赖项的一个替代品，可人为控制。通过使用桩对象，无需设计依赖项，即可对代码直接进行测试。                              
* 反测试 设计本质是：代码依赖于外部资源，即使其逻辑非常正确，也可能导致测试失败。                                        
* 接缝 指代码中可以插入不同功能（如桩对象）的地方。                              
* 构造注入-->IoC容器   ？？？？？                                   
* 使用桩对象解除依赖方法：1.桩对象构造注入或设值注入；2.被测类使用工厂类创建桩对象；3.使用工厂伪对象；4.在被测类中添加虚工厂方法。                       
* 抽象类与接口：抽象类可能已经包含内建的产品依赖（已经有部分实现），需要了解和控制；实现接口可以做到准确了解底层实现，完全控制。                       
* Bob Martin的SOLID设计原则：1.单一职责原则；2.开闭原则；3.里氏替换原则；4.接口分离原则；5.依赖反转原则。                                       
* 可测试设计与面向对象的基本思想有冲突。如果实在希望满足两方面的需求，可以：1.使用internal和[InternalVisibleTo]；2.利用[Conditional]属性标签；3.使用#if和#endif的条件编译。                                      

## 用模拟对象做交互测试                                           
* 交互测试 用来测试一个对象如何向另一个对象传递消息，或者如何从其他对象接收消息，即测试对象如何与其他对象进行交互。              
* 模拟对象（Mock）是系统中的一个伪对象，用来决定一个单元测试是通过还是失败。它通过验证被测对象和伪对象之间是否进行预期的交互来判断。通常每个测试只有一个伪对象。      
* 模拟对象和桩对象的区别：1.桩对象不会使测试失败，模拟对象可以；2.使用桩对象时，断言是针对被测类执行的。借助桩对象，能够确保测试顺利运行。使用模拟对象时，被测类与模拟对象通信，**模拟对象记录所有的消息**。测试利用模拟对象来验证被测对象。                        
* 伪对象是桩对象或模拟对象的概称。一个伪对象是桩对象还是模拟对象，取决于它在当前测试中的用法。如果用来检查交互，它是模拟对象，否则是桩对象。                
* 一个测试一个模拟对象 在测试用可以同时使用模拟对象和桩对象，一个测试应该只能有一个模拟对象，所有其他的伪对象都是桩对象。                                    
* 桩链：产生模拟对象或其他桩的一批桩。                            

## 隔离（模拟对象）框架                        
* 隔离框架 是可以方便地新建模拟对象和桩对象的一组可编程API，它让程序员不用为了测试或模拟对象之间的交互而编写重复的代码。大多数有单元测试的语言都有隔离框架，比如C++有mockpp，Java有jMock和EasyMock等。.Net有NMock、Moq、TypeMock Isolator和Rhino Mocks。                                
* 动态创建伪对象 指在运行时新建的桩对象或模拟对象，它不需要通过手写代码来实现。                                                       
* 伪对象创建的目的就是为了让它有些预期的行为，以便测试。所以，可以用框架动态创建伪对象，并设置预期行为，以便断言测试。                                
* Rhino Mocks：1.录制-回放模式：新建伪对象，设置预期，调用被测类，断言预期；2.设置-操作-断言模式（arrange-act-assert，AAA）：将设置预期放在断言处。               
* 严格模拟对象与非严格模拟对象：1.严格模拟对象StrickMock<T>：只能被明确定义的预期方法所调用；2.非严格模式DynamicMock<T>：允许针对它的任何调用，不管是否对那个调用有预期。                        
* 模拟对象和桩对象的参数约束 隔离测试，忽略掉一些不必要的测试。                                       
* 测试与事件相关的活动：1.测试一个事件已被订阅；2.在模拟对象和桩对象中触发事件；3.测试一个事件是否被触发。                                                
* 隔离框架的优势：1.更容易验证参数；2.更容易验证方法的多次调用；3.更容易创建伪对象。                                         
* 测试细节太多的权衡方法：1.在可能的情况下使用费严格模拟对象；2.在可能的情况下使用桩对象替代模拟对象；3.避免把桩对象用作模拟对象；4.不可再测试中重复逻辑；5.不要使用“神奇”的值，尽量使用硬编码。                                        

## 测试层次及组织                        
* 自动构建过程：1.获取所有相关项目的最新版本；2.编译所有项目的最新版本；3.把构建的输出部署到一台测试服务器；4.在本地或者测试服务器上运行测试；5.基于日期和编号来归档构建输出；6.把输出部署到“临时服务器”，甚至可以部署到生成服务器；7.在服务器上安装并配置组件；8.如果任何一步出错，通知相关人员；9.合并数据库；10.新建构建质量、历史以及测试状态的相关报告；11.如果特定任务失败，自动新建任务或者工作项。                       
* 为应用程序打造测试API:1.使用测试类的继承模式：抽象测试框架类，模板测试类，抽象测试驱动类；2.新建测试工具类和方法：特定的断言工具类，特定的工厂类，特定的配置类或数据库配置类；3.公布API。          
* 总结：1.让测试自动化，使用自动化构建过程，尽量频繁地运行测试；2.把继承测试从单元测试中剥离出来；3.按类型和项目来划分测试；4.使用测试类的层次结构，把同一组测试应用于多个被测的相关类型，或者应用于共有一组接口或基类的过个类型；5.如果测试类的层级结构降低了测试的可读性，使用辅助类和工具类；6.让团队知晓测试API。                   

## 优秀单元测试的支柱              
* 优秀单元测试的三个属性：1.可信赖性；2.可维护性；3.可读性。            
* 编写可信赖测试：1.决定何时删除或更改测试；2.避免测试的逻辑；3.只测一件事件；4.让测试容易运行；5.确保测试覆盖率。                                           
* 实施测试隔离，臭味：1.强制的测试顺序；2.隐藏的测试调用；3.状态共享的污染；4.外部状态共享的污染。                   

## 在组织中引入单元测试               

## 修改遗留代码           
* 从哪里开始添加测试：逻辑驱动（容易测试）；依赖驱动（难以测试）。                           
* 在重构前些集成测试：如果确实计划为了提高可测试性而重构代码，为了保证在重构过程中没有破坏已有逻辑，一个可行的方法是为生产系统编写集成测试。            